let AuthenticationError,ApolloError,UserInputError,prop,propOr,sign,compare,authenticate,hashPassword,SERVER_ERROR,UNAUTHORIZED,INVALID_CREDENTIALS,PASSWORD_RULES,USERNAME_ALREADY_EXISTS,USER_NOT_FOUND,USER_ALREADY_DELETED,PASSWORD_CHANGED;_c4d‍.x([["default",()=>_c4d‍.o]]);_c4d‍.w("apollo-server",[["AuthenticationError",["AuthenticationError"],function(v){AuthenticationError=v}],["ApolloError",["ApolloError"],function(v){ApolloError=v}],["UserInputError",["UserInputError"],function(v){UserInputError=v}]]);_c4d‍.w("ramda",[["prop",["prop"],function(v){prop=v}],["propOr",["propOr"],function(v){propOr=v}]]);_c4d‍.w("jsonwebtoken",[["sign",["sign"],function(v){sign=v}]]);_c4d‍.w("bcryptjs",[["compare",["compare"],function(v){compare=v}]]);_c4d‍.w("../../auth",[["authenticate",["authenticate"],function(v){authenticate=v}],["hashPassword",["hashPassword"],function(v){hashPassword=v}]]);_c4d‍.w("../../messages",[["SERVER_ERROR",["SERVER_ERROR"],function(v){SERVER_ERROR=v}],["UNAUTHORIZED",["UNAUTHORIZED"],function(v){UNAUTHORIZED=v}],["INVALID_CREDENTIALS",["INVALID_CREDENTIALS"],function(v){INVALID_CREDENTIALS=v}],["PASSWORD_RULES",["PASSWORD_RULES"],function(v){PASSWORD_RULES=v}],["USERNAME_ALREADY_EXISTS",["USERNAME_ALREADY_EXISTS"],function(v){USERNAME_ALREADY_EXISTS=v}],["USER_NOT_FOUND",["USER_NOT_FOUND"],function(v){USER_NOT_FOUND=v}],["USER_ALREADY_DELETED",["USER_ALREADY_DELETED"],function(v){USER_ALREADY_DELETED=v}],["PASSWORD_CHANGED",["PASSWORD_CHANGED"],function(v){PASSWORD_CHANGED=v}]]);
















const resolver = {
  Query: {
  },
  Mutation: {
    login: async (parent, args, ctx) => {
      try {
        const user = await ctx.User.findOne({ username: _c4d‍.a("prop",prop)('username')(args),
          isDeleted: false })
        if (!user) return new (_c4d‍.a("AuthenticationError",AuthenticationError))((_c4d‍.a("INVALID_CREDENTIALS",INVALID_CREDENTIALS)))

        const paswordMatched = await _c4d‍.a("compare",compare)(_c4d‍.a("prop",prop)('password')(args), user.password)
        _c4d‍.g.console.log(paswordMatched);
        
        if (!paswordMatched) return new (_c4d‍.a("AuthenticationError",AuthenticationError))((_c4d‍.a("INVALID_CREDENTIALS",INVALID_CREDENTIALS)))

        const payload = {
          username: user.username,
        }
        const token = await _c4d‍.a("sign",sign)(payload, _c4d‍.a("propOr",propOr)('secret for test', 'JWT_SECRET')(process.env))

        return {token : token, username: user.username}  
      } catch (e) {
        _c4d‍.g.console.log(e)
        return new (_c4d‍.a("ApolloError",ApolloError))((_c4d‍.a("SERVER_ERROR",SERVER_ERROR)), '500')
      }
    },
    addUser: async (parent, args, ctx) => {
      try {
        const password = _c4d‍.a("prop",prop)('password')(args)
        //console.log(password);
        const hashedPassword = await _c4d‍.a("hashPassword",hashPassword)(password, _c4d‍.a("prop",prop)('username')(args))
        if (!hashedPassword) return new (_c4d‍.a("UserInputError",UserInputError))((_c4d‍.a("PASSWORD_RULES",PASSWORD_RULES)))

        const user = new ctx.User({
          username: _c4d‍.a("prop",prop)('username')(args),
          password: hashedPassword,
        })
        await user.save()

        const payload = { username: user.username }
        const token = await _c4d‍.a("sign",sign)(payload, _c4d‍.a("propOr",propOr)('secret for test', 'JWT_SECRET')(process.env))

        return {token : token, username: user.username}  
      } catch (e) {
        if (e.errmsg && e.errmsg.split(':')[0] === 'E11000 duplicate key error index') {
          return new (_c4d‍.a("UserInputError",UserInputError))((_c4d‍.a("USERNAME_ALREADY_EXISTS",USERNAME_ALREADY_EXISTS)))
        }
        _c4d‍.g.console.log(e)
        return new (_c4d‍.a("ApolloError",ApolloError))((_c4d‍.a("SERVER_ERROR",SERVER_ERROR)), '500')
      }
    },
    editUser: async (parent, args, ctx) => {
      try {
        const payload = await _c4d‍.a("authenticate",authenticate)(ctx.token)
        if (!payload) return new (_c4d‍.a("AuthenticationError",AuthenticationError))((_c4d‍.a("UNAUTHORIZED",UNAUTHORIZED)))

        const user = await ctx.User.findOne({ username: _c4d‍.a("prop",prop)('username')(args), isDeleted: false })
        if (!user) return new (_c4d‍.a("UserInputError",UserInputError))((_c4d‍.a("USER_NOT_FOUND",USER_NOT_FOUND)))

        const passwordMatched = await _c4d‍.a("compare",compare)(_c4d‍.a("prop",prop)('password')(args), user.password)
        if (!passwordMatched) return new (_c4d‍.a("AuthenticationError",AuthenticationError))((_c4d‍.a("INVALID_CREDENTIALS",INVALID_CREDENTIALS)))

        if (_c4d‍.a("prop",prop)('newPassword')(args)) {
          const password = _c4d‍.a("prop",prop)('newPassword')(args)
          const hashedPassword = await _c4d‍.a("hashPassword",hashPassword)(password, _c4d‍.a("prop",prop)('username')(payload))
          if (!hashedPassword) return new (_c4d‍.a("UserInputError",UserInputError))((_c4d‍.a("PASSWORD_RULES",PASSWORD_RULES)))
          user.password = hashedPassword
        }
        await user.save()

        const userPayload = {
          username: user.username,
        }
        const token = await _c4d‍.a("sign",sign)(userPayload, _c4d‍.a("propOr",propOr)('secret for test', 'JWT_SECRET')(process.env))

        return _c4d‍.a("PASSWORD_CHANGED",PASSWORD_CHANGED)
      } catch (e) {
        _c4d‍.g.console.log(e)
        return new (_c4d‍.a("ApolloError",ApolloError))((_c4d‍.a("SERVER_ERROR",SERVER_ERROR)), '500')
      }
    },
    deleteUser: async (parent, args, ctx) => {
      try {
        const payload = await _c4d‍.a("authenticate",authenticate)(ctx.token)
        if (!payload) return new (_c4d‍.a("AuthenticationError",AuthenticationError))((_c4d‍.a("UNAUTHORIZED",UNAUTHORIZED)))

        const user = await ctx.User.findOne({ username: _c4d‍.a("prop",prop)('username')(args), isDeleted: false })
        if (!user) return new (_c4d‍.a("UserInputError",UserInputError))((_c4d‍.a("USER_NOT_FOUND",USER_NOT_FOUND)))
        if (user.isDeleted) return new (_c4d‍.a("UserInputError",UserInputError))((_c4d‍.a("USER_ALREADY_DELETED",USER_ALREADY_DELETED)))

        user.isDeleted = true
        await user.save()

        return user._id
      } catch (e) {
        _c4d‍.g.console.log(e)
        return new (_c4d‍.a("ApolloError",ApolloError))((_c4d‍.a("SERVER_ERROR",SERVER_ERROR)), '500')
      }
    },
  },
}

_c4d‍.d(resolver);
