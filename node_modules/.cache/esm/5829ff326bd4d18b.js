let AuthenticationError,ApolloError,UserInputError,prop,propOr,sign,compare,authenticate,hashPassword,SERVER_ERROR,UNAUTHORIZED,INVALID_CREDENTIALS,PASSWORD_RULES,USERNAME_ALREADY_EXISTS,USER_NOT_FOUND,USER_ALREADY_DELETED;_6bd‍.x([["default",()=>_6bd‍.o]]);_6bd‍.w("apollo-server",[["AuthenticationError",["AuthenticationError"],function(v){AuthenticationError=v}],["ApolloError",["ApolloError"],function(v){ApolloError=v}],["UserInputError",["UserInputError"],function(v){UserInputError=v}]]);_6bd‍.w("ramda",[["prop",["prop"],function(v){prop=v}],["propOr",["propOr"],function(v){propOr=v}]]);_6bd‍.w("jsonwebtoken",[["sign",["sign"],function(v){sign=v}]]);_6bd‍.w("bcryptjs",[["compare",["compare"],function(v){compare=v}]]);_6bd‍.w("../../auth",[["authenticate",["authenticate"],function(v){authenticate=v}],["hashPassword",["hashPassword"],function(v){hashPassword=v}]]);_6bd‍.w("../../messages",[["SERVER_ERROR",["SERVER_ERROR"],function(v){SERVER_ERROR=v}],["UNAUTHORIZED",["UNAUTHORIZED"],function(v){UNAUTHORIZED=v}],["INVALID_CREDENTIALS",["INVALID_CREDENTIALS"],function(v){INVALID_CREDENTIALS=v}],["PASSWORD_RULES",["PASSWORD_RULES"],function(v){PASSWORD_RULES=v}],["USERNAME_ALREADY_EXISTS",["USERNAME_ALREADY_EXISTS"],function(v){USERNAME_ALREADY_EXISTS=v}],["USER_NOT_FOUND",["USER_NOT_FOUND"],function(v){USER_NOT_FOUND=v}],["USER_ALREADY_DELETED",["USER_ALREADY_DELETED"],function(v){USER_ALREADY_DELETED=v}]]);















const resolver = {
  Query: {
  },
  Mutation: {
    login: async (parent, args, ctx) => {
      try {
        console.log("hey")
        const user = await ctx.User.findOne({ username: prop('username')(args).toLowerCase(),
          isDeleted: false })
        if (!user) return new AuthenticationError(INVALID_CREDENTIALS)

        const paswordMatched = await compare(prop('password')(args), user.password)
        if (!paswordMatched) return new AuthenticationError(INVALID_CREDENTIALS)

        const payload = {
          username: user.username,
        }
        const token = await sign(payload, propOr('secret for test', 'JWT_SECRET')(process.env))

        return token
      } catch (e) {
        _6bd‍.g.console.log(e)
        return new ApolloError(SERVER_ERROR, '500')
      }
    },
    addUser: async (parent, args, ctx) => {
      try {
        const password = prop('password')(args)
        const hashedPassword = await hashPassword(password, prop('username')(args))
        if (!hashedPassword) return new UserInputError(PASSWORD_RULES)

        const user = new ctx.User({
          username: prop('username')(args).toLowerCase(),
          password: hashedPassword,
        })
        await user.save()

        const payload = { username: user.username }
        const token = await sign(payload, propOr('secret for test', 'JWT_SECRET')(process.env))

        return token
      } catch (e) {
        if (e.errmsg && e.errmsg.split(':')[0] === 'E11000 duplicate key error index') {
          return new UserInputError(USERNAME_ALREADY_EXISTS)
        }
        _6bd‍.g.console.log(e)
        return new ApolloError(SERVER_ERROR, '500')
      }
    },
    editUser: async (parent, args, ctx) => {
      try {
        const payload = await authenticate(ctx.token)
        if (!payload) return new AuthenticationError(UNAUTHORIZED)

        const user = await ctx.User.findOne({ username: prop('username')(args).toLowerCase(), isDeleted: false })
        if (!user) return new UserInputError(USER_NOT_FOUND)

        const passwordMatched = await compare(prop('password')(args), user.password)
        if (!passwordMatched) return new AuthenticationError(INVALID_CREDENTIALS)

        if (prop('newPassword')(args)) {
          const password = prop('newPassword')(args)
          const hashedPassword = await hashPassword(password, prop('username')(payload))
          if (!hashedPassword) return new UserInputError(PASSWORD_RULES)
          user.password = hashedPassword
        }
        await user.save()

        const userPayload = {
          username: user.username,
        }
        const token = await sign(userPayload, propOr('secret for test', 'JWT_SECRET')(process.env))

        return token
      } catch (e) {
        _6bd‍.g.console.log(e)
        return new ApolloError(SERVER_ERROR, '500')
      }
    },
    deleteUser: async (parent, args, ctx) => {
      try {
        const payload = await authenticate(ctx.token)
        if (!payload) return new AuthenticationError(UNAUTHORIZED)

        const user = await ctx.User.findOne({ username: prop('username')(args), isDeleted: false })
        if (!user) return new UserInputError(USER_NOT_FOUND)
        if (user.isDeleted) return new UserInputError(USER_ALREADY_DELETED)

        user.isDeleted = true
        await user.save()

        return user._id
      } catch (e) {
        _6bd‍.g.console.log(e)
        return new ApolloError(SERVER_ERROR, '500')
      }
    },
  },
}

_6bd‍.d(resolver);
