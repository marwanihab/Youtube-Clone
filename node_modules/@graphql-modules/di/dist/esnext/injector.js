import { ProviderNotValidError, ServiceIdentifierNotFoundError, DependencyProviderNotFoundError, ProviderAlreadyDefinedError } from './errors';
import { ProviderScope } from './types';
import { isTypeProvider, PROVIDER_OPTIONS, isValueProvider, isClassProvider, isFactoryProvider, DESIGN_PARAMTYPES, DESIGN_TYPE, PROPERTY_KEYS } from './utils';
export class Injector {
    constructor(options = {}) {
        this.options = options;
        this._classMap = new Map();
        this._factoryMap = new Map();
        this._applicationScopeInstanceMap = new Map();
        this._sessionScopeInstanceMap = new Map();
        this._applicationScopeServiceIdentifiers = new Array();
        this._requestScopeServiceIdentifiers = new Array();
        this._sessionScopeServiceIdentifiers = new Array();
        this._hookServiceIdentifiersMap = new Map();
        this._name = this.options.name || Date.now().toString();
        this._injectorScope = this.options.injectorScope || ProviderScope.Application;
        this._defaultProviderScope = this.options.defaultProviderScope || this._injectorScope;
        this._hooks = this.options.hooks || new Array();
        this._initialProviders = this.options.initialProviders || new Array();
        this._children = this.options.children || new Array();
        this.onInstanceCreated = () => { };
        this._sessionSessionInjectorMap = new WeakMap();
        for (const provider of this._initialProviders) {
            if (provider) {
                this.provide(provider);
            }
        }
    }
    addChild(...children) {
        for (const child of children) {
            this._children.push(child);
        }
    }
    removeChild(...children) {
        for (const child of children) {
            this._children.splice(this._children.indexOf(child), 1);
        }
    }
    hasChild(child) {
        return this._children.includes(child);
    }
    getScopeInstanceMap(providerScope = this._injectorScope) {
        switch (providerScope) {
            case ProviderScope.Application:
                return this._applicationScopeInstanceMap;
            case ProviderScope.Session:
                return this._sessionScopeInstanceMap;
            case ProviderScope.Request:
                return new Map();
        }
    }
    provide(provider) {
        if (isTypeProvider(provider)) {
            const options = Reflect.getMetadata(PROVIDER_OPTIONS, provider);
            if (this.has(provider)) {
                throw new ProviderAlreadyDefinedError(this._name, provider);
            }
            this._classMap.set(provider, provider);
            switch ((options && options.scope) || this._defaultProviderScope) {
                case ProviderScope.Application:
                    this._applicationScopeServiceIdentifiers.push(provider);
                    break;
                case ProviderScope.Request:
                    this._requestScopeServiceIdentifiers.push(provider);
                    break;
                case ProviderScope.Session:
                    this._sessionScopeServiceIdentifiers.push(provider);
                    break;
            }
            for (const hook of this._hooks) {
                if (hook in provider.prototype) {
                    if (!this._hookServiceIdentifiersMap.has(hook)) {
                        this._hookServiceIdentifiersMap.set(hook, []);
                    }
                    this._hookServiceIdentifiersMap.get(hook).push(provider);
                }
            }
            return;
        }
        if (this.has(provider.provide)) {
            if (!provider.overwrite) {
                throw new ProviderAlreadyDefinedError(this._name, provider.provide);
            }
            else {
                this._classMap.delete(provider.provide);
                this._factoryMap.delete(provider.provide);
                this.getScopeInstanceMap().delete(provider.provide);
                this._applicationScopeServiceIdentifiers.splice(this._applicationScopeServiceIdentifiers.indexOf(provider.provide), 1);
                this._sessionScopeServiceIdentifiers.splice(this._applicationScopeServiceIdentifiers.indexOf(provider.provide), 1);
                this._requestScopeServiceIdentifiers.splice(this._applicationScopeServiceIdentifiers.indexOf(provider.provide), 1);
            }
        }
        if (isValueProvider(provider)) {
            this.getScopeInstanceMap().set(provider.provide, provider.useValue);
        }
        else if (isClassProvider(provider)) {
            const providedClassOptions = provider.provide['prototype']
                ? Reflect.getMetadata(PROVIDER_OPTIONS, provider.provide)
                : null;
            const useClassOptions = Reflect.getMetadata(PROVIDER_OPTIONS, provider.useClass);
            provider.scope =
                provider.scope ||
                    (providedClassOptions && providedClassOptions.scope) ||
                    (useClassOptions && useClassOptions.scope);
            this._classMap.set(provider.provide, provider.useClass);
            for (const hook of this._hooks) {
                if (hook in provider.useClass.prototype) {
                    if (!this._hookServiceIdentifiersMap.has(hook)) {
                        this._hookServiceIdentifiersMap.set(hook, []);
                    }
                    this._hookServiceIdentifiersMap.get(hook).push(provider.useClass);
                }
            }
        }
        else if (isFactoryProvider(provider)) {
            this._factoryMap.set(provider.provide, provider.useFactory);
        }
        else {
            throw new ProviderNotValidError(this._name, provider['provide'] && provider);
        }
        switch (provider.scope || this._defaultProviderScope) {
            case ProviderScope.Application:
                this._applicationScopeServiceIdentifiers.push(provider.provide);
                break;
            case ProviderScope.Request:
                this._requestScopeServiceIdentifiers.push(provider.provide);
                break;
            case ProviderScope.Session:
                this._sessionScopeServiceIdentifiers.push(provider.provide);
                break;
        }
    }
    has(serviceIdentifier) {
        return (this.getScopeInstanceMap(ProviderScope.Application).has(serviceIdentifier) ||
            this.getScopeInstanceMap(ProviderScope.Session).has(serviceIdentifier) ||
            this._classMap.has(serviceIdentifier) ||
            this._factoryMap.has(serviceIdentifier));
    }
    remove(serviceIdentifier) {
        this.getScopeInstanceMap().delete(serviceIdentifier);
        this._classMap.delete(serviceIdentifier);
        this._factoryMap.delete(serviceIdentifier);
    }
    get scopeServiceIdentifiers() {
        switch (this._injectorScope) {
            case ProviderScope.Application:
                return this._applicationScopeServiceIdentifiers;
            case ProviderScope.Request:
                return this._requestScopeServiceIdentifiers;
            case ProviderScope.Session:
                return this._sessionScopeServiceIdentifiers;
        }
    }
    get(serviceIdentifier, dependencyIndex) {
        const applicationScopeInstanceMap = this.getScopeInstanceMap(ProviderScope.Application);
        const sessionScopeInstanceMap = this.getScopeInstanceMap(ProviderScope.Session);
        if (sessionScopeInstanceMap.has(serviceIdentifier)) {
            return sessionScopeInstanceMap.get(serviceIdentifier);
        }
        else if (applicationScopeInstanceMap.has(serviceIdentifier)) {
            return applicationScopeInstanceMap.get(serviceIdentifier);
        }
        else if (this._classMap.has(serviceIdentifier)) {
            const RealClazz = this._classMap.get(serviceIdentifier);
            try {
                const dependencies = Reflect.getMetadata(DESIGN_PARAMTYPES, RealClazz) || [];
                const dependencyInstances = dependencies.map((dependency, dependencyIndex) => this.get(dependency, dependencyIndex));
                const instance = new RealClazz(...dependencyInstances);
                const propertyKeys = Reflect.getMetadata(PROPERTY_KEYS, RealClazz) || [];
                for (const propertyKey of propertyKeys) {
                    const dependency = Reflect.getMetadata(DESIGN_TYPE, RealClazz.prototype, propertyKey);
                    if (dependency) {
                        Object.defineProperty(instance, propertyKey, {
                            value: this.get(dependency, propertyKeys.indexOf(propertyKey))
                        });
                    }
                }
                if (this._applicationScopeServiceIdentifiers.includes(serviceIdentifier)) {
                    this._applicationScopeInstanceMap.set(serviceIdentifier, instance);
                }
                if (this._sessionScopeServiceIdentifiers.includes(serviceIdentifier)) {
                    this._sessionScopeInstanceMap.set(serviceIdentifier, instance);
                }
                this.onInstanceCreated({ serviceIdentifier, instance });
                return instance;
            }
            catch (e) {
                if (e instanceof ServiceIdentifierNotFoundError) {
                    throw new DependencyProviderNotFoundError(e.serviceIdentifier, RealClazz, this._name, e.dependencyIndex);
                }
                else {
                    throw e;
                }
            }
        }
        else if (this._factoryMap.has(serviceIdentifier)) {
            const factory = this._factoryMap.get(serviceIdentifier);
            const instance = this.call(factory, this);
            if (this._applicationScopeServiceIdentifiers.includes(serviceIdentifier)) {
                this._applicationScopeInstanceMap.set(serviceIdentifier, instance);
            }
            if (this._sessionScopeServiceIdentifiers.includes(serviceIdentifier)) {
                this._sessionScopeInstanceMap.set(serviceIdentifier, instance);
            }
            this.onInstanceCreated({ serviceIdentifier, instance });
            return instance;
        }
        else {
            for (const child of this._children) {
                try {
                    const instance = child.get(serviceIdentifier);
                    return instance;
                }
                catch (e) {
                    if (e instanceof ServiceIdentifierNotFoundError && e.serviceIdentifier === serviceIdentifier) {
                        continue;
                    }
                    else {
                        throw e;
                    }
                }
            }
            throw new ServiceIdentifierNotFoundError(serviceIdentifier, this._name, dependencyIndex);
        }
    }
    hasSessionInjector(session) {
        return this._sessionSessionInjectorMap.has(session);
    }
    getSessionInjector(session) {
        if (!this._sessionSessionInjectorMap.has(session)) {
            const sessionInjector = new Injector({
                name: this._name + '_SESSION',
                injectorScope: ProviderScope.Session,
                hooks: this._hooks,
                children: this._children.map(child => child.getSessionInjector(session))
            });
            sessionInjector._hookServiceIdentifiersMap = this._hookServiceIdentifiersMap;
            sessionInjector._applicationScopeInstanceMap = this._applicationScopeInstanceMap;
            sessionInjector._classMap = this._classMap;
            sessionInjector._factoryMap = this._factoryMap;
            sessionInjector._applicationScopeServiceIdentifiers = this._applicationScopeServiceIdentifiers;
            sessionInjector._requestScopeServiceIdentifiers = this._requestScopeServiceIdentifiers;
            sessionInjector._sessionScopeServiceIdentifiers = [...this._sessionScopeServiceIdentifiers];
            this._sessionSessionInjectorMap.set(session, sessionInjector);
        }
        return this._sessionSessionInjectorMap.get(session);
    }
    destroySessionInjector(session) {
        return this._sessionSessionInjectorMap.delete(session);
    }
    call(fn, thisArg) {
        if ('hasMetadata' in Reflect && Reflect.hasMetadata(DESIGN_PARAMTYPES, fn)) {
            const dependencies = Reflect.getMetadata(DESIGN_PARAMTYPES, fn);
            const instances = dependencies.map((dependency, dependencyIndex) => this.get(dependency, dependencyIndex));
            return fn.call(thisArg, ...instances);
        }
        return fn.call(thisArg, thisArg);
    }
    async hasHook(hook) {
        return this._hookServiceIdentifiersMap.has(hook);
    }
    callHookWithArgs({ async, ...options }) {
        if (async) {
            return this.callHookWithArgsAsync(options);
        }
        else {
            return this.callHookWithArgsSync(options);
        }
    }
    callHookWithArgsSync({ hook, args, instantiate }) {
        const finalResult = {};
        const serviceIdentifiers = this._hookServiceIdentifiersMap.get(hook);
        if (serviceIdentifiers) {
            Object.assign(finalResult, ...serviceIdentifiers.map(serviceIdentifier => {
                if (!instantiate && !this.getScopeInstanceMap().has(serviceIdentifier)) {
                    return {};
                }
                const instance = this.get(serviceIdentifier);
                if (instance) {
                    const result = instance[hook](...args);
                    if (result) {
                        return result;
                    }
                }
                return {};
            }));
        }
        return finalResult;
    }
    async callHookWithArgsAsync({ hook, args, instantiate }) {
        const finalResult = {};
        const serviceIdentifiers = this._hookServiceIdentifiersMap.get(hook);
        if (serviceIdentifiers) {
            Object.assign(finalResult, ...(await Promise.all(serviceIdentifiers.map(async (serviceIdentifier) => {
                if (!instantiate && !this.getScopeInstanceMap().has(serviceIdentifier)) {
                    return {};
                }
                const instance = this.get(serviceIdentifier);
                if (instance) {
                    const result = await instance[hook](...args);
                    if (result) {
                        return result;
                    }
                }
                return {};
            }))));
        }
        return finalResult;
    }
}
//# sourceMappingURL=injector.js.map